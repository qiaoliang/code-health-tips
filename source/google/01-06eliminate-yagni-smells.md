# 消除YAGNI坏味道

软件开发的大部分成本是维护成本。**减少维护成本的一名方法是只在你在需要它时，才实现它**。也就是所谓的* ***“你不需要它（You Aren't Gonna Need It）”*** **(缩写为YAGNI)设计原则。** 如何定位那些不必要的代码？跟着你的鼻子走!

*代码坏味道*是指一种代码模式，通常会暗示着某种设计缺陷。例如，"创建了一个基类或者接口，但却只有一个子类”，这可能意味着写代码的人推测在后续的开发中有可能需要写更多的子类。正确的做法是，**实践增量式的开发与设计 **：直到真正需要第二个子类时，再提取出一个父类或接口。
**下面的C++ 代码就有YAGNI坏味道**:

c++
```c++
class Mammal { ...
           virtual Status Sleep(bool hibernate) = 0;
       }; 
class Human : public Mammal { ...
  virtual Status Sleep(bool hibernate) {
    age += hibernate ? kSevenMonths : kSevenHours;
    return OK;
  }
};
```


当只需要一个类时，使用父子类只是增加了维护者的理解、文档和测试这两个类的负担。在上面的代码片断中， 我们要处理的情况是，即使所有的调用者传递的参数是*false*时，你要也关心hibernate是true的时候的用例；另外，当Sleep函数返回一个error时，也需要处理，尽管根本不会发生这种情况。这就导致根本不可能被执行的无用代码。**请消除这些坏味道，简化代码**:

```c++
class Human { ...
  void Sleep() { age += kSevenHours; }
};
```

**下面还有一些YAGNI 坏味道**:

- 除了测试用例以外，代码根本不被执行(也就是无法到达的死代码）
- 类被实现成了子类（有虚方法和/或protected类型的成员变量），但实际上根本没必要子类化。
- public 或 protected的方法或成员变量本来是可以使用private。
- 参数、变量, 或标志位总是相同的值。

庆幸的是, ** YAGNI 和其它的代码坏味道通常很容易通过寻找简单的实现模式来发现，并且很容易使用简单的重构手段消除**.

你还在添加目前不会被用到的代码么？相信我，*你不会需要它的（YAGNI）*。